package mpascal;

import java_cup.runtime.*;
import java.io.FileReader;
import java.util.ArrayList;
import org.w3c.dom.Document;
import org.w3c.dom.Element;  
import org.w3c.dom.NodeList;
import org.w3c.dom.Node;

parser code {:

	//public PascalProgram root = null;

	//public SymTable symtable = new SymTable();

	public void report_error(String message, Object info) {
		StringBuilder m = new StringBuilder("Sintax Error");
		if (info instanceof java_cup.runtime.Symbol) {
			java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
			if (s.left >= 0) {
				m.append(" at line "+(s.left+1));
				if (s.right >= 0)
					m.append(", column "+(s.right+1));
			}
		}
		m.append(" : " + message);
		System.err.println(m);
	}

	public void report_fatal_error(String message, Object info) {
		report_error(message, info);
		//System.exit(1);
	}

	public void syntax_error(Symbol cur_token) {
		report_error("on Token "+ cur_token.value, cur_token);
	}

	public static void main(String[] args){
		try {
			Parser asin = new Parser(
				new Lexer( new FileReader(args[0])));
			Object result = asin.parse().value;
		} catch (Exception ex) {
			ex.printStackTrace();
		}
	}
	:};

	terminal  PROGRAM, BEGIN, END, ARRAY, DIV, DO, ELSE,
	IF, NOT, OF, OR, THEN, VAR, WHILE, REPEAT, UNTIL, FOR, TO,
	LEFT_PAR, RIGHT_PAR, LEFT_BRACKET, RIGHT_BRACKET, IN,
	SEMICOLON, COLON, COMMA, DOT, ASIGN, PLUS, MINUS,
	DIVIDE, PRODUCT, MOD, EQUALS, NOT_EQUAL,
	GREATER_THAN, LESS_THAN, GREATER_EQUALS, LESS_EQUAL,
	INTEGER, ID, STRING, CHAR, WRITE_LN, READ_LN,
	BOOLEAN, INT_CONST, TRUE, FALSE, CHAR_CONS, PROCEDURE, FUNCTION;

	terminal String STRING_LITERAL;

	non terminal PascalProgram pascalProgram;
	non terminal Block block;
	non terminal Object variableDeclarationPart;
	non terminal VariableDeclarationList variableDeclarationList;
	non terminal VariableDeclaration variableDeclaration;
	non terminal IdentifierList identifierList;
	non terminal Type type;
	non terminal ArrayType arrayType;
	non terminal IndexRange indexRange;
	non terminal SimpleType simpleType;
	non terminal Statements statements;
	non terminal Statement statement;
	non terminal Variable variable;
	non terminal String operational;
	non terminal Expression expression;
	non terminal SimpleExpression simpleExpression;
	non terminal Term term;
	non terminal Factor factor;
	non terminal String termOps;
	non terminal Blocks blocks;
	non terminal FunctionDeclaration functionDeclaration;
	non terminal ProcedureDeclaration procedureDeclaration;
	non terminal Params params;
	non terminal Param param;
	non terminal Expressions expressions;


	precedence left OR ;
	precedence nonassoc EQUALS, NOT_EQUAL, LESS_THAN, GREATER_THAN, LESS_EQUAL, GREATER_EQUALS ;
	precedence left PLUS, MINUS ;
	precedence left PRODUCT, DIVIDE ;
	precedence nonassoc NOT ;
	precedence left DOT, LEFT_BRACKET, RIGHT_BRACKET, LEFT_PAR, RIGHT_PAR ;
	precedence right ELSE;
	precedence left ID;


	start with pascalProgram;

	// program id;
	// [Block]
	// .

	pascalProgram ::= PROGRAM ID:id SEMICOLON blocks:blocks DOT {:
			
		:}
	;

	// [variableDeclarationPart]
	// [statementPart]

	blocks::= block:b blocks:bs {:
			
		:}
	|
		block:b {:
			
		:}
	;

	block::= variableDeclarationPart:vdl {:
			
		:}
	|
		functionDeclaration:fd SEMICOLON {:
			
		:}
	|
		procedureDeclaration:pd SEMICOLON {:
			
		:}
	|
		BEGIN statements:s END {:
			
		:}
	;

	functionDeclaration::= FUNCTION ID:id LEFT_PAR params:p RIGHT_PAR COLON type:t SEMICOLON blocks:b {:
			
		:}
	;

	procedureDeclaration::= PROCEDURE ID:id LEFT_PAR params:p RIGHT_PAR SEMICOLON blocks:b {:
			
		:}
	;

	params::= params:ps SEMICOLON param:p{:
			
		:}
	|
		param:p {:
			
		:}
	;

	param::= identifierList:il COLON type:t {:
			
		:}
	|
		VAR identifierList:il COLON type:t {:
			
		:}
	;


	// VAR
	//	  [variableDeclarationList]

	variableDeclarationPart::= VAR variableDeclarationList:vdl {:
			
		:}
	;

	//    [str, str2, str3 : string;]
	//    [char, char2, char3: char;]

	variableDeclarationList::= variableDeclaration:vd SEMICOLON{:
			
		:}
	|
		variableDeclarationList:vdl variableDeclaration:vd SEMICOLON{:
			
		:}
	;

	// variableDeclaration
	//    [num, num2, num3] : [integer];
	//    [identifierList] : [type];


	variableDeclaration::= identifierList:il COLON type:t {:
			
		:}
	|
		error SEMICOLON {:
			System.err.println("Error at declaration line: Posible missing ; at the end of a declaration line.");
		:}
	;


	// [identifierList] : string
	// char, char2, char3

	identifierList::= ID:id {:
			
		:}
	|
		identifierList:il COMMA ID:id {:
			
		:}
	|
		error {:
			System.err.println("Error at declaration list: Posible missing , in the middle of a declaration list.");
		:}
	;


	// Los tipos pueden ser:
	//	str : string; (sympleType)
	// o
	//	myArray, myArray2 : Array[1..5] of Integer; (arrayType)

	type::= simpleType:st {:
			
		:}
	|
		arrayType:at {:
			
		:}
	;


	// myArray : Array[1..5] of Integer;

	arrayType::= ARRAY LEFT_BRACKET indexRange:ir RIGHT_BRACKET OF simpleType:st {:
			
		:}
	;

	// [1..5]

	indexRange::= factor:start DOT DOT factor:end {:
			
		:}
 	;

 	// words: 'string', 'char', 'integer', 'boolean'

	simpleType::= STRING {:
			
		:}
	|
		CHAR:st {:
			
		:}
	|
		INTEGER:st {:
			
		:}
	|
		BOOLEAN:st {:
			
		:}
	;

	// para la repetici√≥n de statements

	statements::= statement:s {:
			
		:}
	|
		statements:ss SEMICOLON statement:s {:
			
		:}
	;


	// contiene:
	// if e then s
	// if e then s else s
	// while e do s
	// repeate e until s
	// for id := e to e do s
	// v := e
	// begin ss end

	statement::= IF expression:e THEN statement:s {:
			
		:}
	|
		IF expression:e THEN statement:s1 ELSE statement:s2 {:
			
		:}
	|
		WHILE expression:e DO statement:s {:
			
		:}
	|
		REPEAT statement:s UNTIL expression:e {:
			
		:}
	|
		FOR ID:id ASIGN expression:e1 TO expression:e2 DO statement:s {:
			
		:}
	|
		variable:v ASIGN expression:e {:
			
		:}
	|
		BEGIN statements:s END {:
			
		:}
	|
		// Llamado a procedimiento
		ID:id LEFT_PAR expressions:e RIGHT_PAR {:
			// TODO Validar si id esta en la tabla de simbolos de procedimientos
			
		:}
	;

	// agarra el id de una variable normal o el de un arreglo
	// id
	// id[pos]
	// pos puede ser una expresion tipo 4+3

	variable::= ID:id LEFT_BRACKET expressions:e RIGHT_BRACKET {:
			
		:}
	|
		ID:id {:
			
		:}
	;



	operational::= PRODUCT {:
			
		:}
	|
		DIVIDE {:
			
		:}
	|
		GREATER_THAN {:
			
		:}
	|
		LESS_THAN {:
			
		:}
	|
		GREATER_EQUALS {:
			
		:}
	|
		LESS_EQUAL {:
			
		:}
	|
		EQUALS EQUALS {:
			
		:}
	|
		NOT_EQUAL {:
			
		:}
	|
		IN {:
			
		:}
	|
		{:
			RESULT = null;
		:}
	;


	expressions::= expressions:es COMMA expression:e {:
			
		:}
	|
		expression:e {:
			
		:}
	;

	expression::= simpleExpression:se {:
			
		:}
	|
		
		:}
	;


	simpleExpression::= PLUS term:t {:
			
		:}
	|
		MINUS term:t {:
			
		:}
	|
		term:t {:
			
		:}
	|
		simpleExpression:se PLUS term:t {:
			
		:}
	|
		simpleExpression:se MINUS term:t {:
			
		:}
	|
		simpleExpression:se OR term:t {:
			
		:}
	;


	term::= factor:f {:
			
		:}
	|
		factor:f termOps:to term:t {:
			
		:}

	;

	termOps::= PRODUCT {:
			
		:}
	|
		DIVIDE {:
			
		:}
	|
		DIV {:
			
		:}
	|
		MOD {:
			
		:}
	;

	factor::= //Llamado a funcion
		
		:}
	|
		variable:v {:
			
		:}

	|
		LEFT_PAR expression:e RIGHT_PAR {:
			
		:}
	|
		NOT factor:f {:
			
		:}
	|
		INT_CONST:i {:
			
		:}
	|
		STRING_LITERAL:i {:
			
		:}
	|
		CHAR_CONS:i {:
			
		:}
	|
		TRUE:i {:
			
		:}
	|
		FALSE:i {:
			
		:}

	;
